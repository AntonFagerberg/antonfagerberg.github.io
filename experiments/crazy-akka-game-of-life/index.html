<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Crazy Akka Game of Life</title>
        <meta name="viewport" content="width=device-width">
        <link rel="stylesheet" href="/css/main.css">
        <link rel="stylesheet" href="/css/syntax.css">
    </head>
    <body>
      <div id="gradient">&nbsp;</div>
      <div id="header">&nbsp;</div>

      <div id="menu">
        <span class="link-color-0">
            <a href="/">
                Home
            </a>
        </span>
        |
        <span class="link-color-1">
            <a href="/projects">
                Projects
            </a>
        </span>
        |
        <span class="link-color-2">
            <a href="/experiments">
                Experiments
            </a>
        </span>
        |
        <span class="link-color-3">
            <a href="/cv">
                CV (swe)
            </a>
        </span>
        |
        <span class="link-color-5">
            <a href="/work">
                Work
            </a>
        </span>
        |
        <span class="link-color-0">
            <a href="/contact">
                Contact
            </a>
        </span>
      </div>

      <div class="item">
	<h1>Crazy Akka Game of Life</h1>
	<p>As the title says, this is a crazy implementation of Conway&#39;s Game of Life using Akka and Scala. The goal of this implementation was:</p>

<ul>
<li>Use a lot of Actors.</li>
<li>Use lots of Futures.</li>
<li>Avoid using matrix look-ups for calculating cell neighbours.</li>
<li>Not be practical or pragmatic.</li>
<li>Achieve good performance (if I had access to a super computer).</li>
</ul>

<h2>How does it work?</h2>

<p>First off, we have the World which is the main supervisor Actor. It will create one cell Actor for each cell and one Checker Actor for each Cell.</p>

<p>The purpose of the Cell Actor is to know if it is alive or not - and if you tell it how many alive neighbours it has, it will die or become alive. (For the single purpose of using a GUI, it will also be aware of its X- &amp; Y-coordinate even though this was not the initial plan). The Cells initial status (dead or alive) is set randomly.</p>

<p>Each Checker Actor will have a sequence of Cell ActorRefs (the neighbours of an unknown Cell) and the purpose of the Checker is to count how many of them are alive and report it to the World Actor. The Checkers are not aware of any positions in the grid.</p>

<p>Each iteration goes like this:</p>

<ul>
<li>World has a collection of all Cells paired with the corresponding Checker.</li>
<li>World asks all Checkers to find out how many alive Cells are in their sequence and then waits for all of them to respond (via Futures).</li>
<li>Each Checker asks every Cell it knows if it is alive (via Futures).</li>
<li>After each Cell has responded, the Checker counts how many are alive and reports the result to the World.</li>
<li>After all Checkers has responded, the World will tell every Cell how many alive neighbours is has and ask what status it will have the next iteration (via Futures).</li>
<li>Each Cell will live or die and respond with it to the World along with its coordinate.</li>
<li>After every Cell has responded, the World will display the result in the GUI and then go again.</li>
</ul>

<h2>So why is this crazy?</h2>

<p>Well, lets say you want to go with a 100 x 100 grid for the Game of Life. This might result in one thread for the World, one thread for each Cell 100<em>100 = 10,000, one thread for each Checker = 10,000. So we may en up with 20,001 threads. On top of this, each Checker may create 8 Futures and the World may create up to 10,000 Futures at a time - so in a weird worst case scenario, we&#39;ll need about 100,000 threads. Your OS and the JVM might have a thing or two to say about this. So ok, you may not end up with 100,000 threads since every actor will probably not consume one thread - but you will end up with a sh</em>t load of Futures and this will result in way too many threads.</p>

<p>I had a go with a grid of 120x75 which results in 18,001 Actors and it worked fine for about 30 seconds before the thread allocation limit was reached and everything crashed (video: <a href="http://instagram.com/p/dMFn6aA7-X/">instagram.com/p/dMFn6aA7-X</a>).</p>

<h2>Running it</h2>

<p>Use SBT:</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash">sbt run
</code></pre></div>
<p>Change src/main/scala/Main.scala to adjust the number of rows &amp; columns (default is 10x10). You can also change src/main/resources/Application.conf to adjust the Akka settings with number of threads etc. Note that this is also limited by the JVM and your operating system.</p>

<h2>Fake F.A.Q?</h2>

<ul>
<li>The Actor system doesn&#39;t exit when the GUI does.
I know, I made the whole GUI / Akka interaction a hack and there are probably a lot of things wrong with it - especially with threads.</li>
</ul>

<h2>Code</h2>

<p>More information &amp; code on <a href="https://github.com/AntonFagerberg/Crazy-Akka-Game-of-Life">GitHub</a>. </p>

	<span class="notice">22 Aug 2013</span>
</div>

      <script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-40700896-1', 'antonfagerberg.com');
            ga('send', 'pageview');
        </script>
    </body>
</html>
